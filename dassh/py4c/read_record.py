########################################################################
"""
    date: 2019-11-19
    author: Adam Nelson
    editor: Milos Atz
    comment: Methods for unpacking binary CCCC files generated by
        the LegacyRATs code system at Argonne National Laboratory.

"""
########################################################################
import struct  # Interpret strings packed as binary data


# 4C record padding length
_PAD_LEN = 4


def discard_pad(data):
    """Remove the 4 character pad preceding the record
    indicator in the data file
    """
    # val = struct.unpack('i', data[:_PAD_LEN])
    return data[_PAD_LEN:]


def discard_blanks(data):
    """Remove blank spaces from the data file"""
    pos = 0
    for i_char in data:
        char = struct.unpack('s', data[pos:pos + 1])[0].decode()
        if char not in ["*", " "]:
            break
        else:
            pos += 1
    return data[pos:]


def get_array_of_string(num, length, data):
    """Read subset of data as an array of strings

    Parameters
    ----------
    num : int
        Number of entries in the array
    length : int
        Length of the strings in the array
    data : str
        4C binary file

    Returns
    -------
    str
        Truncated 4C binary data file
    list
        List of strings from data file

    """
    results = []
    pos = 0
    for i in range(num):
        val = struct.unpack('{}s'.format(length),
                            data[pos:pos + length])[0].decode()
        results.append(val.strip())
        pos += length
    new_data = data[pos:]
    return new_data, results


def get_terminated_strings(num, data):
    """Parse space- or *- separated strings of variable length

    Parameters
    ----------
    num : int
        Number of substrings to be parsed
    data : str
        4C binary data file

    Returns
    -------
    str
        Truncated 4C binary file
    list
        List of parsed strings

    """
    results = []
    pos = 0
    for i in range(num):
        string = ""
        for i_char in data[pos:]:
            char = struct.unpack('s', data[pos:pos + 1])[0].decode()
            pos += 1
            if char not in ["*", " "]:
                string += char
            elif string:
                break
        results.append(string)
    new_data = data[pos:]
    return new_data, results


def get_array_of_int(num, data):
    """Read array of integers

    Parameters
    ----------
    num : int
        Number of values to be read (length of array)
    data : str
        4C binary data file

    Returns
    -------
    str
        Truncated 4C binary data file
    list
        List of integers

    """
    length = 4
    results = struct.unpack('i' * num, data[:num * length])
    pos = num * length
    new_data = data[pos:]
    return new_data, list(results)


def get_array_of_double(num, data):
    """Read array of doubles (double-precision floats)

    Parameters
    ----------
    num : int
        Number of values to be read (length of array)
    data : str
        4C binary data file

    Returns
    -------
    str
        Truncated 4C binary data file
    list
        List of doubles

    """
    length = 8
    results = struct.unpack('d' * num, data[:num * length])
    pos = num * length
    new_data = data[pos:]
    return new_data, list(results)


def get_array_of_float(num, data):
    """Read array of floats

    Parameters
    ----------
    num : int
        Number of values to be read (length of array)
    data : str
        4C binary data file

    Returns
    -------
    str
        Truncated 4C binary data file
    list
        List of floats

    """
    length = 4
    results = struct.unpack('f' * num, data[:num * length])
    pos = num * length
    new_data = data[pos:]
    return new_data, list(results)
